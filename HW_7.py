# Реализовать класс Matrix (матрица). Обеспечить перегрузку конструктора класса (метод __init__()), который должен
# принимать данные (список списков) для формирования матрицы.
# Подсказка: матрица — система некоторых математических величин, расположенных в виде прямоугольной схемы.
# Следующий шаг — реализовать перегрузку метода __str__() для вывода матрицы в привычном виде.
# Далее реализовать перегрузку метода __add__() для реализации операции сложения двух объектов класса Matrix
# (двух матриц). Результатом сложения должна быть новая матрица.
# Подсказка: сложение элементов матриц выполнять поэлементно — первый элемент первой строки первой матрицы складываем
# с первым элементом первой строки второй матрицы и т.д.
#
class Matrix:
    def __init__(self, my_list):
        self.my_list = my_list

    def __str__(self):
        return '\n'.join(map(str, self.my_list))

    def __add__(self, other):
        for el in range(len(self.my_list)):
            for el2 in range(len(other.my_list[el])):
                self.my_list[el][el2] = self.my_list[el][el2] + other.my_list[el][el2]
        return Matrix.__str__(self)


m = Matrix([[2, 0, 1], [-3, 5, 1], [5, 3, 2], [0, 3, -1]])
new_m = Matrix([[1, 1, 1], [-2, 2, 7], [1, -2, 0], [1, -3, 2]])
print(m.__add__(new_m))

# 2. Реализовать проект расчета суммарного расхода ткани на производство одежды. Основная сущность (класс)
# этого проекта — одежда, которая может иметь определенное название. К типам одежды в этом проекте относятся
# пальто и костюм. У этих типов одежды существуют параметры: размер (для пальто) и рост (для костюма).
# Это могут быть обычные числа: V и H, соответственно.
# Для определения расхода ткани по каждому типу одежды использовать формулы: для пальто (V/6.5 + 0.5),
# для костюма (2 * H + 0.3). Проверить работу этих методов на реальных данных.
# Реализовать общий подсчет расхода ткани. Проверить на практике полученные на этом уроке знания:
# реализовать абстрактные классы для основных классов проекта, проверить на практике работу декоратора @property.

class Cloth:
    def __init__(self, arg):
        self.arg = arg

    @property
    def fabric(self):
        pass

class Suit(Cloth):

    @property
    def fabric(self):
        return self.arg * 2 + 0.3


class Coat(Cloth):

    @property
    def fabric(self):
        return self.arg/6.5 + 0.5

suit = Suit(500)
print(suit.fabric)

coat = Coat(100)
print(coat.fabric)

# 3.Реализовать программу работы с органическими клетками,
# состоящими из ячеек. Необходимо создать класс Клетка. В его конструкторе
# инициализировать параметр, соответствующий количеству ячеек клетки (целое число).
# В классе должны быть реализованы методы перегрузки арифметических операторов:
# сложение (__add__()), вычитание (__sub__()), умножение (__mul__()), деление (__truediv__()).
# Данные методы должны применяться только к клеткам и выполнять увеличение, уменьшение, умножение и
# целочисленное (с округлением до целого) деление клеток, соответственно.
# Сложение. Объединение двух клеток. При этом число ячеек общей клетки должно
# равняться сумме ячеек исходных двух клеток.
# Вычитание. Участвуют две клетки. Операцию необходимо выполнять только если разность количества ячеек
# двух клеток больше нуля, иначе выводить соответствующее сообщение.
# Умножение. Создается общая клетка из двух. Число ячеек общей клетки определяется как произведение
# количества ячеек этих двух клеток.
# Деление. Создается общая клетка из двух. Число ячеек общей клетки определяется как целочисленное деление количества ячеек этих двух клеток.

# В классе необходимо реализовать метод make_order(), принимающий экземпляр класса и количество ячеек в ряду.
# Данный метод позволяет организовать ячейки по рядам.
# Метод должен возвращать строку вида *****\n*****\n*****..., где количество ячеек между \n равно переданному
# аргументу. Если ячеек на формирование ряда не хватает, то в последний ряд записываются все оставшиеся.
# Например, количество ячеек клетки равняется 12, количество ячеек в ряду — 5. Тогда метод make_order()
# вернет строку: *****\n*****\n**.
# Или, количество ячеек клетки равняется 15, количество ячеек в ряду — 5. Тогда метод make_order()
# вернет строку: *****\n*****\n*****.

class Cell:

    def make_order(self, count_row: int):
        l = []
        t_count = self.count_cell // count_row + 1
        t_cell = self.count_cell
        for el in range(1, (t_count + 1)):
            if t_cell > 0:
                if t_cell > count_row:
                    l.append(f"{'*' * count_row}")
                else:
                    l.append(f"{'*' * t_cell}")
                t_cell -= count_row
        return '\n'.join(l)

    def __init__(self, count_cell):
        self.count_cell = int(count_cell)

    def __add__(self, other):
        return self.count_cell + other.count_cell

    def __sub__(self, other):
        sub = self.count_cell - other.count_cell
        if sub > 0:
            return Cell(sub)
        else:
            raise Exception("Клетки больше нет")

    def __mul__(self, other):
        return self.count_cell * other.count_cell

    def __truediv__(self, other):
        return self.count_cell // other.count_cell


cell_1 = Cell(10)
print(cell_1.make_order(4))

cell_2 = Cell(8)
print(cell_2.make_order(4))

print("Сумма клеток: ", cell_1 + cell_2)

print("Разница клеток: ", cell_1 - cell_2)

print("Деление клеток: ", cell_1 / cell_2)

print("Умножение клеток: ", cell_1 * cell_2)

